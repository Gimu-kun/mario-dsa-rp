@page "/challenge/knap-sack/play/dynamic-board"
@model mario_dsa_rp.Namespace.DynamicBoardModel
@using System.Text.Json

@{
Layout = "_Layout";
ViewData["Title"] = "Dynamic Board";
var hh = Math.Floor((decimal)Model.challengeTimer / 3600);
var mm = Math.Floor((decimal)(Model.challengeTimer % 3600) / 60);
var ss = Model.challengeTimer % 60;
}

<link rel="stylesheet" href="~/css/dynamic-board.style.css">

<style>
    .hidden { display: none !important; }
</style>

<div class="play-page">
    <div id="countdown-container" class="hidden">
        <div id="countdown-dialog">3</div>
        <div id="start-dialog" class="hidden">Chi·∫øn th√¥i n√†o!</div>
    </div>
    <!-- ROOM -->
    <div id="room_container" class="@(Model.Mode == "single" ? "hidden" : "")">
        <div class="container py-5">
            <h2 class="mb-4 text-center">Ph√≤ng ch∆°i 2 ng∆∞·ªùi</h2>
            <div class="card shadow-sm p-4">
                <p><strong>M√£ ph√≤ng:</strong> <span id="roomIdDisplay">@Model.roomId ?? "-"</span></p>
                <p><strong>ƒê·ªô kh√≥:</strong> <span>@Model.Difficult</span></p>

                <h5>Danh s√°ch ng∆∞·ªùi ch∆°i</h5>
                <ul id="playerList" class="list-group mb-3"></ul>

                <div class="d-flex gap-2">
                    <button id="copyLinkBtn" type="button" class="btn btn-outline-primary">üìã Copy Link M·ªùi</button>
                    <button id="startGameBtn" type="button" class="btn btn-success" disabled>B·∫Øt ƒë·∫ßu tr√≤ ch∆°i</button>
                </div>
            </div>
        </div>
    </div>

    <!-- GAME -->
    <div id="game-container" class="hidden">
        <!-- (ph·∫ßn game nh∆∞ b·∫°n ƒë√£ c√≥) -->
        <div class="score-box">
            <p class="text-xl font-bold text-success">S·ªë ƒëi·ªÉm hi·ªán t·∫°i: <span id="live-score"></span> ƒëi·ªÉm</p>
            <p class="text-xl font-bold text-primary">ID ƒë·ªÅ: <span id="challenge-id"></span></p>
            </div>

        <div id="congrats-message" class="congrats-overlay">
            <h2 class="congrats-text">üéâ Ch√∫c m·ª´ngÔºÅ üéâ</h2>
            <p class="congrats-sub">B·∫°n ƒë√£ ho√†n th√†nh th·ª≠ th√°ch th√†nh c√¥ng!</p>
        </div>

        <div class="question">
            <div class="question_decor left"></div>
            <p class="question_txt title">C√πng nhau l·∫≠p b·∫£ng quy ho·∫°ch ƒë·ªông nh√© !</p>
            <div class="question_decor right"></div>
        </div>

        <div class="grid auto-cols-max grid-flow-col gap-5 text-center">
            <div class="bg-neutral rounded-box text-neutral-content flex flex-col p-2">
                <span class="countdown font-mono text-5xl">
                    <span id="timer-hour" style="--value:@hh;" aria-live="polite">@hh</span>
                </span>
                Gi·ªù
            </div>
            <div class="bg-neutral rounded-box text-neutral-content flex flex-col p-2">
                <span class="countdown font-mono text-5xl">
                    <span id="timer-minute" style="--value:@mm;" aria-live="polite">@mm</span>
                </span>
                Ph√∫t
            </div>
            <div class="bg-neutral rounded-box text-neutral-content flex flex-col p-2">
                <span class="countdown font-mono text-5xl">
                    <span id="timer-second" style="--value:@ss;" aria-live="polite">@ss</span>
                </span>
                Gi√¢y
            </div>
        </div>

        <div class="question-content position-sticky top-5 left-5 z-3">
            <table class="item-table horizontal">
                <thead>
                <tr id="item-header"><th>V·∫≠t ph·∫©m</th></tr>
                </thead>
                <tbody>
                <tr id="item-weight-row"><td>Tr·ªçng l∆∞·ª£ng (w)</td></tr>
                <tr id="item-value-row"><td>Gi√° tr·ªã (v)</td></tr>
                </tbody>
                <tfoot>
                <tr><td id="capacity-cell" colspan="1"></td></tr>
                </tfoot>
            </table>
        </div>

        <div id="dp-board-game" class="playing-container z-1">
            <div class="dp-table-wrapper">
                <table id="dp-table" class="dp-table" style="--col-count: 20">
                    <thead><tr id="dp-header"><th style="min-width:200px">V·∫≠t Ph·∫©m\S·ª©c ch·ª©a</th></tr></thead>
                    <tbody id="dp-body"></tbody>
                </table>
            </div>
        </div>

        <div id="choose-item-game" class="playing-container container hidden">
            <div class="row gy-5 m-5"></div>
            <div class="knapsack-container mt-5 text-center">
                <div id="knapsack" class="knapsack-img" ondrop="dropItem(event)" ondragover="allowDrop(event)">
                    <img src="~/assets/mario_hat.png" alt="Bag" id="bag-image"/>
                </div>
                <p class="mt-3">
                    ‚öñÔ∏è Tr·ªçng l∆∞·ª£ng hi·ªán t·∫°i: <span id="bag-weight">0</span><br/>
                    üí∞ Gi√° tr·ªã hi·ªán t·∫°i: <span id="bag-value">0</span>
                </p>
                <div id="bag-warning" class="text-danger fw-bold"></div>
                <div class="mt-2">
                    <button id="return-last-btn" class="btn btn-sm btn-warning" onclick="returnLastItem()">‚Ü© Tr·∫£ 1 m√≥n</button>
                    <button id="return-all-btn" class="btn btn-sm btn-danger" onclick="returnAllItems()">üóë Tr·∫£ t·∫•t c·∫£</button>
                </div>
            </div>
        </div>

        <div class="btn-container" id="result-buttons"></div>
    </div>
</div>

@section Scripts {
    <script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/7.0.5/signalr.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.3/dist/confetti.browser.min.js"></script>

<script>
    // s·ª≠ d·ª•ng JsonSerializer ƒë·ªÉ nh√∫ng string an to√†n v√†o JS
    const mode = @Html.Raw(JsonSerializer.Serialize(Model.Mode));
    const roomIdFromServer = @Html.Raw(JsonSerializer.Serialize(Model.roomId)); // c√≥ th·ªÉ null
    const challengeId = @Html.Raw(JsonSerializer.Serialize(Model.Id));       // ƒë√¢y l√† challenge id (ƒë·ªÅ)
    const difficult = @Html.Raw(JsonSerializer.Serialize(Model.Difficult));
    let userId = @Html.Raw(JsonSerializer.Serialize(Model.UserId));
    let username = @Html.Raw(JsonSerializer.Serialize(Model.FullName));
    let isFinished = false;
    let stage = "dp";
    let answer;
    let maxTime = 6000;
    let dpBoard;
    let dpBoardWithMiss;
    let gameMaxScore = 0;
    let gameTimer;
    let currentScore;
    let takens;
    let removedItems = [];
    let bagWeight = 0;
    let bagValue = 0;
    let maxCapacity;
    let resultItemsList;

    function updateTimerUI(seconds) {
        const hourEl = document.getElementById("timer-hour");
        const minuteEl = document.getElementById("timer-minute");
        const secondEl = document.getElementById("timer-second");
        const hh = Math.floor(seconds / 3600);
        const mm = Math.floor((seconds % 3600) / 60);
        const ss = seconds % 60;

        hourEl.textContent = hh;
        hourEl.setAttribute('aria-label', hh);
        hourEl.style.setProperty('--value', hh);

        minuteEl.textContent = mm;
        minuteEl.setAttribute('aria-label', mm);
        minuteEl.style.setProperty('--value', mm);

        secondEl.textContent = ss;
        secondEl.setAttribute('aria-label', ss);
        secondEl.style.setProperty('--value', ss);
    }
    
    function startTimer(){
        const countDownContainer = document.getElementById("countdown-container");
        const countDownDialog = document.getElementById("countdown-dialog");
        const startDialog = document.getElementById("start-dialog");
        const gameContainer = document.getElementById("game-container");
        let countdown = 3;
        //Hi·ªán khung ƒë·∫øm ng∆∞·ª£c
        countDownContainer.classList.remove("hidden");
        const timer = setInterval(() => {
            countdown--;
            if (countdown >= 0) {
                countDownDialog.textContent = countdown;
            } else {
                //Hu·ª∑ timer
                clearInterval(timer);
                //·∫®n ƒë·∫øm ng∆∞·ª£c
                countDownDialog.classList.add("hidden");
                //Hi·ªán c√¢u n√≥i b·∫Øt ƒë·∫ßu
                startDialog.classList.remove("hidden");
                //Delay 1s
                setTimeout(() => {
                    //·∫®n kh·ªëi ƒë·∫øm ng∆∞·ª£c
                    countDownContainer.classList.add("hidden");
                    //Hi·ªán kh·ªëi tr√≤ ch∆°i
                    gameContainer.classList.remove("hidden");
                    challengeTimer = 0;
                    updateTimerUI(challengeTimer);
                    gameTimer = setInterval(() => {
                        challengeTimer++;
                        currentScore = Math.max(0, Math.floor(gameMaxScore * (1 - challengeTimer / maxTime)));
                        document.getElementById("live-score").textContent = currentScore;
                        updateTimerUI(challengeTimer);
                    }, 1000);
                }, 1000);
            }
        }, 1000);
    }
    
    // fallback n·∫øu roomId kh√¥ng c√≥ ·ªü server (l·∫•y t·ª´ querystring)
    let roomId = roomIdFromServer || (new URLSearchParams(window.location.search)).get("roomId") || "";
    let currentHostId;
    
    if (!userId) userId = "guest-" + Math.floor(Math.random() * 10000);
    if (!username) username = "Kh√°ch " + Math.floor(Math.random() * 1000);

    let connection = null;

    // ====== Kh·ªüi t·∫°o danh s√°ch answer DP ======
    function initAnswerList(dp){
        let answer = [];
        for (let i = 0; i < dp.length; i++) {
            for (let j = 0; j < dp[i].length; j++) {
                if (dp[i][j] === -1){
                    answer.push({ x:i, y:j, v:0 });
                }
            }
        }
        return answer;
    }

    // ----- SignalR + room logic -----
    async function startRoom() {
        connection = new signalR.HubConnectionBuilder()
            .withUrl("http://localhost:5119/roomhub")
            .build();

        // Player list update
        connection.on("PlayerListUpdated", (players, hostId) => {
            currentHostId = hostId;
            const list = document.getElementById("playerList");
            list.innerHTML = "";
            players.forEach(p => addUserToList(p.userId, p.username));
            console.log(players);
            const startBtn = document.getElementById("startGameBtn");
            if (userId === hostId) {
                startBtn.disabled = players.length < 2;
                startBtn.style.display = "inline-block";
            } else {
                startBtn.style.display = "none";
            }
        });

        // When server starts game -> show game UI
        connection.on("GameStarted", (players) => {
            localStorage.setItem("players", JSON.stringify(players));
            
            document.getElementById("room_container").classList.add("hidden");
            startTimer()
            // host s·∫Ω generate v√† chia s·∫ª challenge; non-host s·∫Ω ch·ªù event ChallengeGenerated
            const host = players.find(p => p.userId === currentHostId);
            if (host && host.userId === userId) {
                getChallenge();
            }
        });

        // Khi host share challenge t·ªõi c√°c client
        connection.on("ChallengeGenerated", (challengeResponse,maxScore) => {
            console.log("üì• Nh·∫≠n ƒë·ªÅ b√†i t·ª´ host (SignalR):", challengeResponse);
            answer = initAnswerList(challengeResponse.challenge.dpBoardWithMiss);
            dpBoard = challengeResponse.challenge.dpBoard;
            dpBoardWithMiss = challengeResponse.challenge.dpBoardWithMiss;
            gameMaxScore = maxScore;
            maxCapacity = challengeResponse.challenge.maxCapacity;
            resultItemsList =challengeResponse. challenge.resultItems;
            takens = challengeResponse.taken;
            document.getElementById("challenge-id").innerHTML = challengeResponse.challenge.id;
            localStorage.setItem("challenge", JSON.stringify(challengeResponse.challenge));
            // t√πy structure response: n·∫øu b·∫°n tr·∫£ { challenge: { ... } } th√¨ d√πng .challenge
            const payload = challengeResponse.challenge;
            buildTemplate(payload);
        });

        //Khi thay ƒë·ªïi ƒë√°p √°n th√¨ ƒë·ªìng b·ªô v·ªõi nh·ªØng ng∆∞·ªùi trong ph√≤ng
        connection.on("CellAnswered", (payload) => {
            console.log("üì• CellAnswered t·ª´ player kh√°c:", payload);
            applyCellAnswer(payload.x, payload.y, payload.v);
        });

        connection.on("ItemDropped", (payload) => {
            console.log("üì• ItemDropped t·ª´ player kh√°c:", payload);
            applyDroppedItem(payload);
        });

        connection.on("ReturnLastItem", (payload) => {
            if (payload.userId === userId) return; // b·ªè qua c·ªßa m√¨nh
            console.log("üì• ReturnLastItem t·ª´ player kh√°c:",payload);
            applyReturnLastItem(payload.elementId);
        });

        connection.on("ReturnAllItems", (payload) => {
            if (payload.userId === userId) return;
            console.log("üì• ReturnAllItems t·ª´ player kh√°c:",payload);
            applyReturnAllItems(payload.items);
        });

        await connection.start();
        console.log("‚úÖ SignalR connected");

        // G·ªçi JoinRoom v·ªõi roomId (ph·∫£i c√≥ roomId cho multiplay)
        if (!roomId) {
            console.warn("roomId tr·ªëng khi JoinRoom; ki·ªÉm tra querystring ho·∫∑c server truy·ªÅn roomId.");
        }
        await connection.invoke("JoinRoom", roomId, userId, username);
    }

    // n·∫øu l√† multiplay th√¨ startRoom(); single th√¨ hi·ªán th·∫≥ng game v√† g·ªçi getChallenge
    if (mode === "multiplay") {
        startRoom();
    } else if (mode === "single") {
        document.getElementById("room_container")?.classList.add("hidden");
        startTimer()
        // n·∫øu b·∫°n mu·ªën l·∫•y challenge t·ª´ server theo challengeId
        getChallenge();
    }

    document.getElementById("copyLinkBtn")?.addEventListener("click", () => {
        const link = `${location.origin}/challenge/knap-sack/play/dynamic-board?roomId=${roomId}&difficult=${difficult}&mode=multiplay`;
        navigator.clipboard.writeText(link).then(() => alert("ƒê√£ copy link m·ªùi!"));
    });

    document.getElementById("startGameBtn")?.addEventListener("click", async (e) => {
        e.preventDefault();
        if (!connection) return alert("Ch∆∞a k·∫øt n·ªëi room.");
        await connection.invoke("StartGame", roomId, userId);
    });

    function addUserToList(uId, uName) {
        const list = document.getElementById("playerList");
        const li = document.createElement("li");
        li.classList.add("list-group-item");
        li.textContent = `${uName} (${uId})`;
        list.appendChild(li);
    }

    // ===== Challenge generation / build =====
    let challenge = null;

    async function getChallenge() {
        try {
            // playerList cho server (single: ch·ªâ m√¨nh; multiplay: l·∫•y t·ª´ localStorage players)
            let playerList = [];
            if (mode === "single") {
                playerList = [userId];
            } else {
                const storedPlayers = localStorage.getItem("players");
                playerList = storedPlayers ? JSON.parse(storedPlayers).map(p => p.userId) : [];
            }

            // IMPORTANT: id query param = challengeId (ƒë·ªÅ). Kh√¥ng d√πng roomId ·ªü ƒë√¢y.
            const response = await fetch(
                `http://localhost:5119/api/challenge/generate?type=dp_board&difficulty=${encodeURIComponent(difficult)}&mode=${encodeURIComponent(mode)}&id=${encodeURIComponent(challengeId)}`,
                {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(playerList)
                }
            );

            if (!response.ok) throw new Error("‚ùå L·ªói khi g·ªçi API: " + response.statusText);

            const challengeResponse = await response.json();
            console.log("üì• Challenge nh·∫≠n ƒë∆∞·ª£c (API):", challengeResponse);
            answer = initAnswerList(challengeResponse.challenge.dpBoardWithMiss);
            dpBoard = challengeResponse.challenge.dpBoard;
            dpBoardWithMiss = challengeResponse.challenge.dpBoardWithMiss;
            gameMaxScore = challengeResponse.taken[0].maxScore;
            takens = challengeResponse.taken;
            localStorage.setItem("challenge", JSON.stringify(challengeResponse));
            maxCapacity = challengeResponse.challenge.maxCapacity;
            resultItemsList = challengeResponse.challenge.resultItems;
            document.getElementById("challenge-id").innerHTML = challengeResponse.challenge.id;
            // Host chia s·∫ª cho player kh√°c (qua roomId)
            if (mode === "multiplay" && connection) {
                console.log("challengeResponse multiple",challengeResponse);
                await connection.invoke("ShareChallenge", roomId, challengeResponse, gameMaxScore);
            }

            // L·∫•y payload th·ª±c t·∫ø (t√πy structure API)
            challenge = challengeResponse.challenge ?? challengeResponse;
            buildTemplate(challenge);

        } catch (err) {
            console.error("üö® L·ªói khi getChallenge:", err);
        }
    }

    // build DOM t·ª´ challenge (items, dp board, cubes)
    function buildTemplate(ch) {
        if (!ch) return;
        const headerRow = document.getElementById("item-header");
        const weightRow = document.getElementById("item-weight-row");
        const valueRow = document.getElementById("item-value-row");
        const capacityCell = document.getElementById("capacity-cell");

        headerRow.innerHTML = "<th>V·∫≠t ph·∫©m</th>";
        weightRow.innerHTML = "<td>Tr·ªçng l∆∞·ª£ng (w)</td>";
        valueRow.innerHTML = "<td>Gi√° tr·ªã (v)</td>";

        (ch.quesData || []).forEach((item, idx) => {
            headerRow.innerHTML += `<th>${idx + 1}</th>`;
            weightRow.innerHTML += `<td>${item.weight}</td>`;
            valueRow.innerHTML += `<td>${item.value}</td>`;
        });

        capacityCell.setAttribute("colspan", (ch.quesData?.length || 0) + 1);
        capacityCell.innerText = "S·ª©c ch·ª©a : " + (ch.maxCapacity ?? "-");

        // DP header & body
        const dpHeader = document.getElementById("dp-header");
        const dpBody = document.getElementById("dp-body");
        dpHeader.innerHTML = `<th style="min-width:200px">V·∫≠t ph·∫©m \\ S·ª©c ch·ª©a</th>`;
        for (let w = 0; w <= (ch.maxCapacity || 0); w++) {
            dpHeader.innerHTML += `<th>${w}</th>`;
        }

        dpBody.innerHTML = "";
        for (let i = 0; i <= (ch.quesData?.length || 0); i++) {
            let rowHtml = `<tr><td>${i}</td>`;
            for (let w = 0; w <= (ch.maxCapacity || 0); w++) {
                const isMissing = (ch.dpBoardWithMiss && ch.dpBoardWithMiss[i] && ch.dpBoardWithMiss[i][w] === -1);
                const trueValue = ch.dpBoard && ch.dpBoard[i] ? ch.dpBoard[i][w] : "";
                const cellId = `dp-${i}-${w}`;

                if (isMissing) {
                    rowHtml += `
                        <td id="${cellId}" class="dp-cell">
                            <input type="number" class="dp-input-field" onchange="answerChange(${i}, ${w}, event)"/>
                        </td>`;
                } else {
                    rowHtml += `
                        <td id="${cellId}" class="dp-cell hidden-cell" data-value="${trueValue}">
                            ${trueValue}
                        </td>`;
                }
            }
            rowHtml += "</tr>";
            dpBody.innerHTML += rowHtml;
        }

        // Cube items
        const cubeContainer = document.querySelector("#choose-item-game .row");
        cubeContainer.innerHTML = "";
        (ch.quesData || []).forEach(item => {
            cubeContainer.innerHTML += `
                <div class="col-2 d-flex justify-content-center">
                    <div class="cube"
                         id="cube-${item.id}"
                         draggable="true"
                         ondragstart="dragItem(event)"
                         data-weight="${item.weight}"
                         data-value="${item.value}">
                        <div class="face front">
                            <div class="item-info text-center">
                                <span class="item-value">üí∞ ${item.value}</span>
                                <span class="item-weight">‚öñÔ∏è ${item.weight}</span>
                            </div>
                        </div>
                        <div class="face back"></div>
                        <div class="face right"></div>
                        <div class="face left"></div>
                        <div class="face top"></div>
                        <div class="face bottom"></div>
                    </div>
                </div>`;
        });
    }

    // ====== DP BOARD ======
    function answerChange(x, y, e) {
        if (isFinished || stage !== "dp") return;
        const val = parseInt(e.target.value, 10) || 0;
        const existing = answer.find(a => a.x === x && a.y === y);
        console.log(existing);
        console.log(answer);
        if (existing) existing.v = val;
        else answer.push({ x, y, v: val });

        if (val === dpBoard[x][y]) {
            const cell = document.getElementById(`dp-${x}-${y}`);
            cell.innerHTML = `<span class="dp-input-field correct">${val} ‚úÖ</span>`;
            revealAllHiddenCellsWithValue(val);
        }

        // üîë check xem t·∫•t c·∫£ ƒë√£ ƒë√∫ng ch∆∞a
        const allCorrect = answer.every(a => a.v === dpBoard[a.x][a.y]);
        if (allCorrect) {
            unlockItemStage();
        }

        // üîπ G·ª≠i SignalR cho c√°c player kh√°c
        if (mode === "multiplay" && connection) {
            connection.invoke("SendCellAnswer", roomId, {
                x: x,
                y: y,
                v: val,
                userId: userId
            });
        }
    }

    //H√†m c·∫≠p nh·∫≠t c√¢u tr·∫£ l·ªùi t·ª´ ng∆∞·ªùi ch∆°i kh√°c
    function applyCellAnswer(x, y, val) {
        // n·∫øu √¥ ch∆∞a c√≥ th√¨ t√¨m v√† ƒëi·ªÅn
        const cell = document.getElementById(`dp-${x}-${y}`);
        console.log("cell",cell);
        if (!cell) return;
        
        const existing = answer.find(a => a.x === x && a.y === y);
        if (existing) existing.v = val;
        console.log("existing",existing);
        
        // n·∫øu gi√° tr·ªã ƒë√∫ng
        if (val === dpBoard[x][y]) {
            cell.innerHTML = `<span class="dp-input-field correct">${val} ‚úÖ</span>`;
            revealAllHiddenCellsWithValue(val);
        }
        
        // üîë check xem t·∫•t c·∫£ ƒë√£ ƒë√∫ng ch∆∞a
        console.log("answer",answer);
        console.log("resultList",dpBoard);
        const allCorrect = answer.every(a => a.v === dpBoard[a.x][a.y]);
        console.log("allCorrect",allCorrect);
        if (allCorrect) {
            unlockItemStage();
        }
    }


    function revealAllHiddenCellsWithValue(value) {
        for (let i = 0; i < dpBoard.length; i++) {
            for (let j = 0; j < dpBoard[i].length; j++) {
                if (dpBoard[i][j] === value && dpBoardWithMiss[i][j] !== -1) {
                    const cell = document.getElementById(`dp-${i}-${j}`);
                    if (cell && cell.classList.contains("hidden-cell")) {
                        cell.classList.remove("hidden-cell");
                        cell.classList.add("revealed");
                        cell.textContent = value;
                    }
                }
            }
        }
    }
    
    function revealAllHiddenCells() {
        for (let i = 0; i < dpBoard.length; i++) {
            for (let j = 0; j < dpBoard[i].length; j++) {
                if (dpBoardWithMiss[i][j] !== -1) {
                    const cell = document.getElementById(`dp-${i}-${j}`);
                    if (cell && cell.classList.contains("hidden-cell")) {
                        cell.classList.remove("hidden-cell");
                        cell.classList.add("revealed");
                        cell.textContent = dpBoard[i][j];
                    }
                }
            }
        }
    }

    // ====== Khi DP xong ‚Üí m·ªü item game ======
    function unlockItemStage() {
        stage = "items";
        revealAllHiddenCells();
        document.getElementById("choose-item-game").classList.remove("hidden");
    }
    
    // ====== ITEM GAME (knapsack) ======
    function allowDrop(ev) { ev.preventDefault(); }
    
    function dragItem(ev) {
        const cube = ev.target.closest('.cube') || ev.target;
        if (!cube) return;
        ev.dataTransfer.setData("text/plain", JSON.stringify({
            weight: cube.dataset.weight,
            value: cube.dataset.value,
            elementId: cube.id
        }));
    }

    function dropItem(ev) {
        if (stage !== "items") return;
        ev.preventDefault();
        const data = JSON.parse(ev.dataTransfer.getData("text/plain"));
        const w = parseInt(data.weight, 10);
        const v = parseInt(data.value, 10);

        if (bagWeight + w > maxCapacity) {
            document.getElementById("bag-warning").innerText = "‚ö†Ô∏è T√∫i ƒë√£ ƒë·∫ßy!";
            return;
        }

        const originalCube = document.getElementById(data.elementId);
        if (!originalCube) return;
        const parentWrapper = originalCube.closest('.col-2');
        if (!parentWrapper) return;

        const parentContainer = parentWrapper.parentElement;
        const index = Array.from(parentContainer.children).indexOf(parentWrapper);

        const itemBadge = document.createElement("div");
        itemBadge.className = "badge bg-success m-1";
        itemBadge.innerText = `üí∞${v} | ‚öñÔ∏è${w}`;
        document.getElementById("knapsack").appendChild(itemBadge);

        removedItems.push({
            id: data.elementId,
            node: parentWrapper,
            weight: w,
            value: v,
            badge: itemBadge,
            originalParent: parentContainer,
            originalIndex: index
        });

        parentWrapper.remove();

        bagWeight += w;
        bagValue += v;
        document.getElementById("bag-weight").innerText = bagWeight;
        document.getElementById("bag-value").innerText = bagValue;
        
        if (mode === "multiplay" && connection) {
            connection.invoke("SendItemDropped", roomId, {
                operateUserId: userId,
                elementId: data.elementId,
                weight: w,
                value: v
            });
        }

        checkFinalResult();
    }

    function applyDroppedItem(payload) {
        const { elementId, weight, value, OperateUserId } = payload;
        console.log("elementId",elementId)
        console.log("weight",weight)
        console.log("value",value)
        console.log("userId",userId)
        // N·∫øu ch√≠nh m√¨nh ƒë√£ drop th√¨ b·ªè qua (tr√°nh l·∫∑p)
        if (OperateUserId === userId) return;

        const w = parseInt(weight, 10);
        const v = parseInt(value, 10);
        
        const originalCube = document.getElementById(elementId);
        console.log(originalCube)
        if (!originalCube) return;
        const parentWrapper = originalCube.closest('.col-2');
        console.log(parentWrapper)
        if (!parentWrapper) return;

        const parentContainer = parentWrapper.parentElement;
        const index = Array.from(parentContainer.children).indexOf(parentWrapper);

        const itemBadge = document.createElement("div");
        itemBadge.className = "badge bg-info m-1"; // kh√°c m√†u cho d·ªÖ ph√¢n bi·ªát
        itemBadge.innerText = `üí∞${v} | ‚öñÔ∏è${w}`;
        document.getElementById("knapsack").appendChild(itemBadge);

        removedItems.push({
            id: elementId,
            node: parentWrapper,
            weight: w,
            value: v,
            badge: itemBadge,
            originalParent: parentContainer,
            originalIndex: index
        });

        parentWrapper.remove();

        bagWeight += w;
        bagValue += v;
        document.getElementById("bag-weight").innerText = bagWeight;
        document.getElementById("bag-value").innerText = bagValue;

        checkFinalResult();
    }



    function checkFinalResult() {
        const currentIds = removedItems.map((item) => item.id.replace("cube-", ""));
        const correctIds = resultItemsList;
        let ok = true;
        for (const i of correctIds) {
            if (!currentIds.includes(i)) {
                ok = false;
                break;
            }
        }
        if (ok) {
            finishGame();
        }
}

    // ====== K·∫øt th√∫c game: g·ªçi API ======
    async function finishGame() {
        if (isFinished) return;
        isFinished = true;
        clearInterval(gameTimer);

        document.getElementById("congrats-message").style.display = "block";
        setTimeout(() => { document.getElementById("congrats-message").style.display = "none"; }, 2000);
        startConfetti();
        
        const btnContainer = document.getElementById("result-buttons");
        btnContainer.innerHTML = '';
        const rankingBtn = document.createElement("button");
        rankingBtn.textContent = "Xem b·∫£ng x·∫øp h·∫°ng";
        rankingBtn.classList.add("btn-ranking");
        rankingBtn.onclick = () => window.location.href = "/ranking?view=dp-board";
        btnContainer.appendChild(rankingBtn);

        const payload = {
            SpendTime: challengeTimer,
            TakenScore: Number(document.getElementById("live-score").textContent),
            UserAnswer: JSON.stringify({ dp: answer, items: removedItems.map(r => r.id) })
        };

        try {
            console.log(takens);
            const takenId = takens.find(i => i.userId === userId);
            console.log(takenId);
            if(!takenId) return;
            const res = await fetch(`http://localhost:5119/api/take-challenge/save?id=${takenId.id}`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(payload)
            });
            if (res.ok) {
                
            }
        } catch (err) {
            console.error("Fetch error:", err);
            alert("‚ùå C√≥ l·ªói x·∫£y ra khi g·ª≠i d·ªØ li·ªáu.");
        }
}

    // ====== Confetti ======
    function startConfetti() {
        var end = Date.now() + (8 * 1000);
        var colors = ['#bb0000', '#ffffff'];
        (function frame() {
            confetti({ particleCount: 2, angle: 60, spread: 55, origin: { x: 0 }, colors: colors });
            confetti({ particleCount: 2, angle: 120, spread: 55, origin: { x: 1 }, colors: colors });
            if (Date.now() < end) requestAnimationFrame(frame);
        })();
    }

    // ====== Tr·∫£ 1 m√≥n g·∫ßn nh·∫•t ======
    function returnLastItem() {
        if (removedItems.length === 0) return;
        const last = removedItems.pop();

        if (last.badge && last.badge.parentElement) {
            last.badge.remove();
        }

        // Lu√¥n tr·∫£ v·ªÅ cu·ªëi danh s√°ch g·ªëc
        animateFlyBack(last.node, last.originalParent);

        bagWeight -= last.weight;
        bagValue -= last.value;
        document.getElementById("bag-weight").innerText = bagWeight;
        document.getElementById("bag-value").innerText = bagValue;
        document.getElementById("bag-warning").innerText = "";
        
        // üîπ ph√°t s·ª± ki·ªán
        if (mode === "multiplay" && connection) {
            connection.invoke("SendReturnLastItem", roomId, {
                userId: userId,
                elementId: last.id
            });
        }
    }



    // ====== Tr·∫£ t·∫•t c·∫£ ======
    function returnAllItems() {
        const returnItems = [...removedItems];
        while (removedItems.length > 0) {
            const item = removedItems.pop();
            if (item.badge && item.badge.parentElement) {
                item.badge.remove();
            }
            animateFlyBack(item.node, item.originalParent);
        }

        bagWeight = 0;
        bagValue = 0;
        document.getElementById("bag-weight").innerText = bagWeight;
        document.getElementById("bag-value").innerText = bagValue;
        document.getElementById("bag-warning").innerText = "";

        // üîπ ph√°t s·ª± ki·ªán
        if (mode === "multiplay" && connection) {
            console.log("phat su kien")
            console.log("removedItems",removedItems)
            connection.invoke("SendReturnAllItems", roomId, {
                userId: userId,
                items: returnItems.map(i => i.id)
            });
        }
    }



    function animateFlyBack(itemNode, targetParent) {
        const bag = document.getElementById("knapsack");
        const bagRect = bag.getBoundingClientRect();
        const parentRect = targetParent.getBoundingClientRect();

        // L·∫•y v·ªã tr√≠ "cu·ªëi danh s√°ch" = bottom-right c·ªßa container
        const dx = parentRect.right - bagRect.left - 60; // 60 = width cube
        const dy = parentRect.bottom - bagRect.top - 60; // 60 = height cube

        // Clone node ƒë·ªÉ bay
        const clone = itemNode.cloneNode(true);
        clone.classList.add("fly-back");
        document.body.appendChild(clone);

        // ƒê·∫∑t v·ªã tr√≠ ban ƒë·∫ßu
        clone.style.left = bagRect.left + "px";
        clone.style.top = bagRect.top + "px";

        // G√°n bi·∫øn transform
        clone.style.setProperty("--dx", dx + "px");
        clone.style.setProperty("--dy", dy + "px");

        // Khi animation xong ‚Üí x√≥a clone + append node th·∫≠t v·ªÅ cu·ªëi danh s√°ch
        clone.addEventListener("animationend", () => {
            clone.remove();
            targetParent.appendChild(itemNode);
        });
    }

    function applyReturnLastItem(elementId) {
        const idx = removedItems.findIndex(i => i.id === elementId);
        if (idx === -1) return;
        const item = removedItems.splice(idx, 1)[0];

        if (item.badge && item.badge.parentElement) {
            item.badge.remove();
        }
        animateFlyBack(item.node, item.originalParent);

        bagWeight -= item.weight;
        bagValue -= item.value;
        document.getElementById("bag-weight").innerText = bagWeight;
        document.getElementById("bag-value").innerText = bagValue;
    }

    function applyReturnAllItems(itemIds) {
        try {
            console.log("üü¢ applyReturnAllItems ƒë∆∞·ª£c g·ªçi v·ªõi:", itemIds);
            console.log("üì¶ removedItems tr∆∞·ªõc:", removedItems);

            removedItems = removedItems.filter(item => {
                if (itemIds.includes(item.id)) {
                    console.log("‚Ü©Ô∏è Tr·∫£ l·∫°i item:", item);
                    if (item.badge && item.badge.parentElement) {
                        item.badge.remove();
                    }
                    animateFlyBack(item.node, item.originalParent);
                    return false;
                }
                return true;
            });

            bagWeight = 0;
            bagValue = 0;
            document.getElementById("bag-weight").innerText = bagWeight;
            document.getElementById("bag-value").innerText = bagValue;
            document.getElementById("bag-warning").innerText = "";

            console.log("üì¶ removedItems sau:", removedItems);
            console.log("‚öñÔ∏è bagWeight:", bagWeight, "üí∞ bagValue:", bagValue);
        } catch (err) {
            console.error("‚ùå applyReturnAllItems b·ªã l·ªói:", err);
        }
    }
</script>
}
